### Shiro的功能

- 身份认证登录
- 授权，授权某个用户有没有操作权限
- 会话管理，管理用户登陆后的会话信息
- 加密，持久化加密
- 缓存，缓存权限及会话信息
- 并发验证，即线程间的验证信息的同步
- 测试
- 记住我

**Shiro 不会去维护用户、维护权限；这些需要我们自己去设计 / 提供；然后通过相应的接口注入给 Shiro 即可**



### Shiro的一些角色

- **Subject**：主体，可以看到主体可以是任何可以与应用交互的 “用户”；
- **SecurityManager**：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。
- **Authenticator**：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；
- **Authrizer**：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；
- **Realm**：可以有 1 个或多个 Realm，**可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等**；由用户提供；注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm；
- **SessionManager**：如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所有呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；
- **SessionDAO**：DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；
- **CacheManager**：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能
- **Cryptography**：密码模块，Shiro 提高了一些常见的加密组件用于如密码加密 / 解密的。



### 认证登录的过程

很简单，比如说我有一个人过来想进门，我请了一个保安在门口帮我验证他是不是可以进去的，那么首先我要先去正规的人才市场招一个保安，然后到家之后我告诉他我们家用的是密码本还是保险柜，然后他就会跟我我给他的密码本信息去门口拦下每一个人，问他的账号密码是什么，逐一对比，如果不符合就会过来告诉我。

那么具体一点的话：

1. 如果这个人拿的是通行证而不是身份证，那么能对比吗，不可以。可以的话才可以进行下一步。
2. 缓存功能，如果刚刚已经来过一次了，那么下次能很快地让他进去。
3. 可以设置多种验证通道，分别检查身份证和居住证，可以设置通过一个就行也可以设置全部通过才可以



### 授权功能

- 基于角色的访问控制
  - 用户登录成功后，会给他一个身份，这个身份会在realm中保存，可以有多个身份
  - 每个方法都是基于某个用户是否有某个角色
  - hasRole\hasRoles\checkRole\checkRoles   查看用户是否是这（个/些）角色
  - realm中只需要有用户与其对应的角色，**在执行方法前判断用户角色是否可以执行这个方法**。
  - 问题：粒度太粗，修改起来很麻烦
- 基于资源的访问控制
  - isPermitted  \  isPermittedAll \  checkPermission \  checkPermissions  判断该用户是否有这（个/些）操作的权限
  - realm中不仅要有用户的角色，还要有角色所对应的权限，也就是这个角色能做什么。**事先就知道这个用户能做什么**。
  - 标识权限的一般规则是“**资源标识符：操作：实例ID**”
    - `role41=system:user:update,system:user:delete`  可以简写为  `role42="system:user:update,delete`
    - 如果拥有对某个资源的所有权限可以写成：system:user:*
- 授权方式
  - 编程式，通过Subject（主体）判断一个用户是否拥有某个角色，有的话就执行方法
  - 注解式，使用@RequiresRoles标注在方法上，拥有这个角色的用户才可以执行这个方法



### 使用Mysql作为Realm

- 首先准备用户表、角色表、权限表，另外还需要准备 **用户-角色**、**角色-权限** 关联表。